【Git】
****************************************************************
Git 简介
****************************************************************
    - 目前世界上最先进的分布式版本控制系统（没有之一）。
    - 特性：
        1. 文件历史版本
        2. 文件修改版本合并
        3. 记录改动
· 诞生
    - Linux创始人为了做版本管理，有了Git
· 集中式vs分布式
    
· Git 安装
    - linux
       $ sudo apt-get install git
    - Max OS X
        方法一：用homebrew http://brew.sh/
        方法二：从AppStore安装Xcode
    - Windows
        下载msysgit ： https://git-for-windows.github.io
        安装菜单：git>Git Bash, 命令行
        $ git config --global user.name "Your Name"
        $ git config --global user.email "email@example.com"

· 创建版本库repository
    1. 创建q目录
    2. 
        $ git init
        Initialized empty Git repository in /Users/michael/learngit/.git/
    3. 会出现一个隐藏的.git目录. 用ls -ah 查看
    4. 把文件添加到版本库
        在repo目录下：
        $ git add readme.txt    //添加readme文件
        $ git commit -m "wrote a readme file"       // 提交， -m 后为提交说明

    * windows 千万别使用自带的记事本编辑文件。 请使用Notepad++，并把默认编码设置为UTF-8 without BOM
        https://notepad-plus-plus.org/

****************************************************************
版本控制
****************************************************************
· 时光机穿梭
     $ git status   // 获取版本库当前状态（增删改等等）
     $ git diff readme.txt  // 查看制定文件的改动部分
     $ git add readme.txt   
     $ git commit -m 'version comments here'

· 版本回退
    $ git log   //查看历史记录
    $ git log --pretty=oneline      // commit id

    - 在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。

    $ git reset --hard HEAD^        // 退回到第一个版本
    $ git reset --hard 88215ef // 什么号,版本号

    $git reflog     //记录你的每一次命令
【小结】
    小结
    现在总结一下：
    HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。
    穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
    要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。

· 工作区和暂存区
    - 工作区： 就是你在电脑里能看到的Git目录
    - 版本库（Repository） 
        工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
        - stage（或者叫index）的暂存区
        - master //我们自动创建的第一个分支Master
        - 指向Master的指针HEAD
    - git add 命令实际上就是把要提交的所有修改放到暂存区（Stage）
    - git commit 就可以一次性把暂存区的所有修改提交到分支。

· 管理修改
    - Git管理的是修改，而不是文件
    - 什么是修改：比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。

    [小结]
    理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。
· 撤销修改
    $ git checkout -- readme.txt

· 删除文件
    $ rm test.txt
    $ git commit -m "remove test.txt"
    $ git checkout -- test.txt      //误删恢复



****************************************************************
远程仓库
****************************************************************
 Git账号申请及设置
    1. 注册GitHub账号 github.com
    2. $ ssh-keygen -t rsa -C "imliuye@163.com" 
            // 创建keygen /Users/yeliu/.ssh/id_rsa
    3. GitHub.com > account setting > SSH Keys > Add SSH Key
        title 随意，内容为id_rsa.pub

    为啥GitHub 需要Key： 确认是你推送，不是别人冒充。SSH协议，知道了你的公钥，只有你自己才能推送

    GitHub允许你添加多个Key，在不同电脑。

    所有内容公有。除非付费或者自己搭建Git服务器。

· 添加远程库
    - 右上角+号 > create a new repo > 填写repo name
    - $ git remote add originLJL git@github.com:imliuye/learngit.git
        // 关联远程库originLJL随便起， 

    - $ git push -u originLJL master    //本地内容推送到远程

· 从远程库克隆到本地
    - 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。
    - Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。

    1. 在Git Hub 上 创建苦gitskills
    -$ git clone git@github.com:imliuye/gitskills.git

****************************************************************
分支管理
****************************************************************
· 创建&合并分支
    - Git时间线： 由每次提交时间创建，这个时间线就是分支
    - 主分支 master分支
        · HEAD指向Master，Head指向的，是当前分支
        · Master 指向提交的
        · 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交
        · master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长
        · 当创建新的分支：例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上
            - 从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：
            - 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：
            - 甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支
    - 实践：
        1.  $ git checkout -b dev   // Switched to a new branch 'dev'
                    // 创建并切换到dev分支
                    // git checkout命令加上-b参数表示创建并切换,相当于以下两条命令
                    $ git branch dev
                    $ git checkout dev
                    Switched to branch 'dev'
                    $ git branch    
                    * dev
                      master
                    //用git branch命令查看当前分支,列出所有分支，当前分支前面会标一个*号
        2.  $ git add readme.txt 
            $ git commit -m "branch test" //修改readme.txt 文件并提交
        3.  $ git checkout master
            //dev分支的工作完成，我们就可以切换回master分支

        4. $ git merge dev
            // 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变
            //把dev分支的工作成果合并到master分支上

        5. $ git branch -d dev
            // 合并完成后，就可以放心地删除dev分支了
            //$ git branch 查看，发现没了
    - 小结
        小结
        Git鼓励大量使用分支：
        查看分支：git branch
        创建分支：git branch <name>
        切换分支：git checkout <name>
        创建+切换分支：git checkout -b <name>
        合并某分支到当前分支：git merge <name>
        删除分支：git branch -d <name>

· 解决冲突
    - $ git checkout -b feature1
    - 在freautre1分支上修改readme.txt 加上 AND simple
    - $ git add readme.txt 
      $ git commit -m "AND simple"
      //在feature1分支上提交
    - 切换到master
    - $ git checkout master
        Switched to branch 'master'
        Your branch is ahead of 'origin/master' by 1 commit.
        Git还会自动提示我们当前master分支比远程的master分支要超前1个提交

    - 在master分支上把readme.txt文件的最后一行改为：
        $ git add readme.txt 
        $ git commit -m "& simple"

    - 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：
        $ git merge feature1
        Auto-merging readme.txt
        CONFLICT (content): Merge conflict in readme.txt
        Automatic merge failed; fix conflicts and then commit the result.

    - Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容
    - $ git log --graph --pretty=oneline --abbrev-commit
        // 查看分支图片

    - $ git branch -d featurel
        // 删除分支
    - 小结
        当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
        用git log --graph命令可以看到分支合并图。

· 分支管理策略
    - 通常 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
    - 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息
    - 试试 --no-ff方式的git merge

    1. $ git checkout -b dev
    2. readme.txt文件，并提交一个新的commit
    3. $ git checkout master
    ** 4. $ git merge --no-ff -m "merge with no-ff" dev
        // --no-ff参数，表示禁用Fast forward：
    5. $git log --graph --pretty=oneline --abbrev-commit

    - 分支策略
        1. master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活
        2. 干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本

小结
    - Git分支十分强大，在团队开发中应该充分应用。
    - 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。

· Bug分支
    - 问题描述： 你手上有dev的工作1天后才能提交，但是bug需要2小时内解决
    - 解决： Git提供stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：
    - $ git stash
        // 这个时候dev为clean

    - $ 修福bug并提交
    - $ git stash list
    - 恢复：
        1. 用git stash apply恢复，恢复后，需要用git stash drop来删除
        2. git stash pop 恢复的同时，把stash删除

· Feature分支
    - 

· 多人协作：
    $ git remote    // 查看远程库的信息
    $ git push origin master    // 把该分支上的所有本地提交推送到远程库
    $ git push origin dev   //如果要推送其他分支，比如dev，就改成：

    - 抓取分支
    你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：
    $ git checkout -b dev origin/dev
    $ git push origin dev 

    $ git pull  先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：

小结

    查看远程库信息，使用git remote -v；
    本地新建的分支如果不推送到远程，对其他人就是不可见的；
    从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
    在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
    建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
    从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。

多人协作的工作模式通常是这样：
    首先，可以试图用git push origin branch-name推送自己的修改；
    如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
    如果合并有冲突，则解决冲突，并在本地提交；
    没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！
    如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。


****************************************************************
标签管理
****************************************************************
    - 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照
    - 其实它就是指向某个commit的指针
· 创建标签
    1. 切换到需要打标签的分支上：
        $ git branch
        * dev
          master
        $ git checkout master
        Switched to branch 'master
    2. 打一个新标签：git tag <name> 
        $ git tag v1.0
    3. 看所有标签
       $ git tag
    4. 给过去某个commit打标签需要知道版本号
        $ git tag v0.9 6224937
    5. 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：
        $ git tag -a v0.1 -m "version 0.1 released" 3628164

    6.可以通过-s用私钥签名一个标签：
        $ git tag -s v0.2 -m "signed version 0.2 released" fec145a
        签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：

        gpg: signing failed: secret key not available
        error: gpg failed to sign the data
        error: unable to sign the tag
    ·小结
        -命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；
        git tag -a <tagname> -m "blablabla..."可以指定标签信息；
        git tag -s <tagname> -m "blablabla..."可以用PGP签名标签；
        命令git tag可以查看所有标签。

· 操作标签
    1. 删除
        $ git tag -d v0.1
    2. 推送远程
        $ git push origin v1.0  //推送某个标签
        $ git push origin --tags    //推送全部标签
    3. 删除远程标签
        - $ git tag -d v0.9 //先从本地删除：
        - $ git push origin :refs/tags/v0.9 //再删除远程

小结
    命令git push origin <tagname>可以推送一个本地标签；
    命令git push origin --tags可以推送全部未推送过的本地标签；
    命令git tag -d <tagname>可以删除一个本地标签；
    命令git push origin :refs/tags/<tagname>可以删除一个远程标签。


****************************************************************
使用gitHub
****************************************************************
    例如https://github.com/twbs/bootstrap， 点击folk,就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：
    git clone git@github.com:imliuye/bootstrap.git

小结
    在GitHub上，可以任意Fork开源仓库；
    自己拥有Fork后的仓库的读写权限；
    可以推送pull request给官方仓库来贡献代码。











