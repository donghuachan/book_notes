
******************************************************************************
 函数的参数：
位置参数

默认参数
def power(x, n=2):

可变参数
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum


关键字参数
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

命名关键字参数
def person(name, age, *, city, job):

>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer

def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)

参数组合

******************************************************************************

递归函数
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)

栈溢出：fact(1000)栈溢出
解决栈溢出：尾递归
    
尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
def fact(n):
    return fact_iter(n, 1)
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)

   
******************************************************************************

高级特性

· 切片
    L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
    >>> L[0:3] 
    ['Michael', 'Sarah', 'Tracy']
    >>> L[:3]
    ['Michael', 'Sarah', 'Tracy']
    >>>  L[1:3]
    ['Sarah', 'Tracy']
    >>> L[-2:]
    ['Bob', 'Jack']
    >>> L[-2:-1]
    ['Bob']
    >>> L[::2]
    ['Michael','Tracy','Jack']
    >>>  L[:]
    ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
    
    tuple切片
    >>> (0, 1, 2, 3, 4, 5)[:3]
    (0, 1, 2)
    >>> 'ABCDEFG'[:5:2]
    'ACE'

· 迭代
    >>> d = {'a': 1, 'b': 2, 'c': 3}
    >>> for key in d:
    ...     ...
    >>> for k, v in d.items()
    ...     ...
    >>> for ch in 'ABC':
    ...     ...

    - 判断对象是否可迭代：
    >>> from collections import Iterable
    >>> isinstance('abc', Iterable) # str是否可迭代
    True

    - 需要下标
    >>> for i, value in enumerate(['A', 'B', 'C']):
    ...     print(i, value)
    >>> for x, y in [(1, 1), (2, 4), (3, 9)]:
    ...     print(x, y)

· 列表生成式
    >>> list(range(1, 11))      // 生成列表
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> [x * x for x in range(1, 11)]    // 平方
    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
    >>> [x * x for x in range(1, 11) if x % 2 == 0]     // 偶数平方
    [4, 16, 36, 64, 100]
    >>> [m + n for m in 'ABC' for n in 'XYZ']   //全排列
    ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
    >>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
    >>> [k + '=' + v for k, v in d.items()]
    ['y=B', 'x=A', 'z=C']

· 生成器 generator
    - 原理： 创建很大大的列表，浪费空间。 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间

    >>> g = (x * x for x in range(10))
    >>> g
    <generator object <genexpr> at 0x1022ef630>

    - 如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：

    >>> next(g)
    0
    >>> next(g)
    1

    >>> for n in g:
    ...     print(n)

    - 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator
    def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
生成器不知道怎么写

·迭代器
    - 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator
    - 可以使用isinstance()判断一个对象是否是Iterable对象：

    >>> from collections import Iterable
    >>> isinstance([], Iterable)
    True    

    >>> isinstance([], Iterator)
    False
    >>> isinstance({}, Iterator)
    False
    >>> isinstance('abc', Iterator)
    False

    生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

    >>> isinstance(iter([]), Iterator)
    True
    >>> isinstance(iter('abc'), Iterator)
    True

· 小结

    - 凡是可作用于for循环的对象都是Iterable类型；
    - 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
    - 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。
    - Python的for循环本质上就是通过不断调用next()函数实现的，例如：
    for x in [1, 2, 3, 4, 5]:
        pass

******************************************************************************
函数式编程 Funational Programming

特点：
    - 抽象程度高，不像传统纯函数编程那样固定输入、固定输出
    - 允许把函数本身作为参数传入另一个函数，还允许返回一个函数！

· 高阶函数 Higher-order function
    - 变量可以指向函数
        >>> f = abs
        >>> f(-10)
        10
    - 传入函数
        def add(x, y, f):
            return f(x) + f(y)

· map/reduce
    - map:map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator

        >>> def f(x):
        ...     return x * x
        ...
        >>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
        >>> list(r)
        [1, 4, 9, 16, 25, 36, 49, 64, 81]

    - reduce: 一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
        reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

    











